<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nokia 3310 Ringtone Maker</title>

    <!-- CSS Section -->
    <style>
    </style>
</head>

<body>

<!-- Header Section -->
<header>
</header>

<!-- Main Content Section -->
<main>

    <textarea id="rtttl" rows="3" cols="60">d=4,o=5,b=100: a4,f8,g8</textarea><br>

    <button id="createButton">Play & Record & Download</button>

</main>

<!-- JavaScript Section -->
<script>

    // GLOBAL STATE

    let g_toneLoaded = false;
    let g_synth = null;
    let g_currentPart = null;  // Keep track of the current part

    // EVENT BINDINGS

    document.getElementById('createButton').addEventListener('click', onCreateButtonClick);

    // EVENT HANDLERS

    async function onCreateButtonClick() {
        // TODO kmere What happens if clicked twice quickly?
        console.log("onCreateButtonClick");

        try {
            // Load Tone.js on first click
            if (!g_toneLoaded) {
                await loadTone();
                g_toneLoaded = true;
            }

            // Initialize synth on first click if not already created
            if (!g_synth) {
                g_synth = new Tone.Synth({oscillator: {type: 'square'}}).toDestination();
            }

            await Tone.start();

            // Stop any previous transport
            Tone.Transport.stop();
            // Reset transport to beginning
            Tone.Transport.position = 0;

            // Dispose of previous part if it exists
            if (g_currentPart) {
                g_currentPart.dispose();
            }

            const {settings, notes} = parseRtttl(document.getElementById('rtttl').value);
            console.log(settings);
            console.log(notes);

            Tone.Transport.bpm.value = settings.bpm;

            let time = 0.0;
            const toneNotes = notes.map(n => {
                const res = {
                    time: time,
                    note: n.note,
                    dur: n.duration
                };
                time += Tone.Time(n.duration).toSeconds();
                return res;
            });
            console.log(toneNotes);

            // Create new part
            g_currentPart = new Tone.Part((time, note) => {
                g_synth.triggerAttackRelease(note.note, note.dur, time);
            }, toneNotes.map(n => [n.time, n]));

            // Start the part at the beginning of the timeline
            g_currentPart.start(0);

            // Start the transport
            Tone.Transport.start();
        } catch (error) {
            console.error("Error in onCreateButtonClick:", error);
        }
    }

    function loadTone() {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = "https://unpkg.com/tone";
            script.onload = resolve;
            script.onerror = reject;
            document.body.appendChild(script);
        });
    }

    // FUNCTIONS WITHOUT SIDE-EFFECTS

    function parseRtttl(rtttl) {
        const [settingsStr, notesStr] = rtttl.split(':');
        console.log(settingsStr);
        console.log(notesStr);
        const settings = parseRtttlSettings(settingsStr);
        console.log(settings);
        let notes = notesStr.split(',')
            .map(parseRtttlNote);
        console.log(notes);
        notes = notes.map(n => convertRtttlNote(settings, n));
        console.log(notes);
        return {
            settings: settings,
            notes: notes
        };
    }

    function parseRtttlNote(noteStr) {
        const match = noteStr.match(/(\d*)([a-gp])(#?)(\d*)(\.?)/i);
        const [_, duration, note, sharp, octave, halfExtend] = match;
        return {
            duration: duration,
            note: note.toUpperCase(),
            sharp: !!sharp,
            octave: octave,
            halfExtend: !!halfExtend
        };
    }

    function parseRtttlSettings(settingsStr) {
        const settings = Object.fromEntries(
            settingsStr.split(',').map(s => s.split('='))
        );
        return {
            bpm: parseInt(settings.b || 63),
            octave: parseInt(settings.o || 5),
            duration: parseInt(settings.d || 4)
        };
    }

    function convertRtttlNote(settings, rtttlNote) {
        const duration = (rtttlNote.duration || settings.duration)
            + 'n'
            + (rtttlNote.halfExtend ? '.' : '');
        let note = rtttlNote.note === 'p' ? null : rtttlNote.note;
        if (!!note && rtttlNote.sharp) note += '#';
        if (!!note) note += rtttlNote.octave || settings.octave;
        return {
            duration: duration,
            note: note
        };
    }

</script>

</body>

</html>
